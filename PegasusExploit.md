# Pegasus Kernel Exploit for iOS 9.0 - 9.3.4

My attempt to understand the Pegasus Kernel Exploit for iOS 9.0 - 9.3.4 and create a working exploit for this kernel exploit. 

# Overview of ```OSUnserializeBinary```

The XNU kernel implements a function called ```OSUnserializeXML```, which deserializes an XML formatted input to a basic kernel data object. Recently a newly added function called ```OSUnserializeBinary``` was added that converts binary formatted data to a basic kernel object.

## The OSUnserializeBinary's Binary Format

The binary data that ```OSUnserializeBinary``` processes is a simple data stream of ```uint32_t``` i.e 32-bit integers contiguous integers. Another way to look at them is an array of integers that each describe a something.

The very first integer of a valid data stream is a unique signature ```0x000000d3```. Every other integer value after the signature uses some of its bits to describe its data type and size. Integers also can represent pure raw data.

```objc
/* 0x000000d3 */
#define kOSSerializeBinarySignature "\323\0\0"

enum {
    kOSSerializeDictionary      = 0x01000000U,
    kOSSerializeArray           = 0x02000000U,
    kOSSerializeSet             = 0x03000000U,
    kOSSerializeNumber          = 0x04000000U,
    kOSSerializeSymbol          = 0x08000000U,
    kOSSerializeString          = 0x09000000U,
    kOSSerializeData            = 0x0a000000U,
    kOSSerializeBoolean         = 0x0b000000U,
    kOSSerializeObject          = 0x0c000000U,

    kOSSerializeTypeMask        = 0x7F000000U,
    kOSSerializeDataMask        = 0x00FFFFFFU,

    kOSSerializeEndCollection   = 0x80000000U,
};
```

The structure of each of these integers is as follows where the bit 31 is used to indicated whether the collection is over or not, and bits 30 through 24 are used for storing the data type, and finally bits 23 through 0 represent the actual elements lenghts.

![Bit Structure](images/bitstructure.png)

```
0x000000d3 0x81000000 0x09000004 0x00414141 0x8b000001
```

The binary data above corresponds to:

```xml
<dict>
    <string>AAA</string>
    <boolean>1</boolean>
</dict>
```

We mark the dictionary as the last element of the first collection (```0x81000000```), and the boolean as the last element of the second collection (```0x8b000001```). Then we encode the string data (```AAA```) directly inline with the null terminating byte (```0x00414141```). For the boolean we don't need to inline the data because the size determines ```TRUE``` or ```FALSE```.

Here is an important note about the concept of a collection and marking it's end. A collection is a group of objects on the same level. For example, elements inside of a dictionary are all part of the same collection. When making a binary dictionaries for ```OSUnserializeBinary``` it is important to always mark the end of a collection, setting the first bit flag (```kOSSerializeEndCollection``` in the enum). Here's an XML example to.

```xml
<dict>                          <!-- dict, level 0 | END! -->
    <string>AAA</string>        <!-- string, level 1 -->
    <boolean>1</boolean>        <!-- bool, level 1 -->

    <string>BBB</string>        <!-- string, level 1 -->
    <boolean>1</boolean>        <!-- bool, level 1 -->

    <dict>                      <!-- dict, level 1 -->
        <string>CCC</string>    <!-- string, level 2 -->
        <boolean>1</boolean>    <!-- bool, level 2 | END! -->
    </dict>

    <string>DDD</string>        <!-- string, level 1 -->
    <boolean>1</boolean>        <!-- bool, level 1 | END! -->
</dict>
```

In this example there are various levels there, or collections. We marked every last element in every level/collection. If we don't ```OSUnserializeBinary``` will exit and return with a bad argument error. Also note that in the case of the outer dictionary, we marked it as last element since it is the one and only element on level/collection 0.

## The OSUnserializeBinary Analysis

```OSUnserializeBinary``` is only called inside ```OSUnserializeXML```. If this function detects unique binary signature (```0x000000d3```) at the beginning of the input data, it will know that it is indeed binary data and not XML data and hand everything off to the ```OSUnserializeBinary``` function.

lib/kern/c++/OSUnserializeXML.cpp
```cpp
OSObject* OSUnserializeXML(const char *buffer, size_t bufferSize, OSString **errorString)
{
    if (!buffer)
        return (0);
    if (bufferSize < sizeof(kOSSerializeBinarySignature))
        return (0);

    if (!strcmp(kOSSerializeBinarySignature, buffer))
        return OSUnserializeBinary(buffer, bufferSize, errorString);

    // XML must be null terminated
    if (buffer[bufferSize - 1]) return 0;

    return OSUnserializeXML(buffer, errorString);
}
```

The actual code for ```OSUnserializeBinary```, updated to last OS X vulnerable version, ```10.11.6```, is available [here](https://github.com/jndok/xnu/blob/aea2bdfb13661311a23bc0659dd5104d48a10081/libkern/c%2B%2B/OSSerializeBinary.cpp#L258-L476)

What the code does is iterate over the buffer containing binary data, on ```uint32_t``` at a time, and parses each one. During the parsing it will create a ```OSObject*``` that will be then returned. The returned object must be a container object that is to say the object contains other objects. This means that it is either a dictionary, an array, or a set because these are the only supported containers implemented.

This also means that there can only be one object on level 0 also known as the first collection, and it must be a container. So that is to say that all the binary data has to be encapsulataed in a in one of the supported formats arrays, dictionaries, or sets. If there are any other formats before or after level 0 it will be ignored.

Here is the code.

```objc
...

    while (ok)
    {
        bufferPos += sizeof(*next);
        if (!(ok = (bufferPos <= bufferSize))) break;
        key = *next++;

        len = (key & kOSSerializeDataMask);
        wordLen = (len + 3) >> 2;
        end = (0 != (kOSSerializeEndCollecton & key));

        newCollect = isRef = false;
        o = 0; newDict = 0; newArray = 0; newSet = 0;

        switch (kOSSerializeTypeMask & key)
        {
            case kOSSerializeDictionary:
            ...

            case kOSSerializeArray:
            ...

            case kOSSerializeSet:
            ...

            case kOSSerializeObject:
            ...

            case kOSSerializeNumber:
            ...

            case kOSSerializeSymbol:
            ...

            case kOSSerializeString:
            ...

            case kOSSerializeData:
            ...

            case kOSSerializeBoolean:
            ...

            default:
                break;
        }

        ...
```

After the function does some basic intialization and basic checks, the function start the main ```while(ok)``` loop. This the unserializing code, this code iterates over the binary data, integer per integer, and deserializes the data object.

In the beging of the code we have the loop incrementing code, which also reads the current integer into ```key```, The length of the current data is then calculated and stored into ```len```. Finally the boolean ```end``` is set if the ```kOSSerializeEndCollection``` flag which is the 31st bit is set in the current key.

Then, the data type of the ```key``` is then checked with switch case, with a case for each data type and then allocates object corresponding to the it's formatted data type.

Here is what the case for ```kOSSerializeDictionary``` looks like.

```objc
case kOSSerializeDictionary:
    o = newDict = OSDictionary::withCapcity(len);
    newCollect = (len != 0)
    break;
```

Here ```o``` is an ```OSObject``` pointer which points to currently de-serialized object for the current loop and is set inside each of case.

```objc
case kOSSerializeData:
    bufferPos += (wordLen * sizeof(uint32_t));
    if (bufferPos > bufferSize) break;
    o = OSData::withBytes(next, len)
    next += wordLen;
    break;
```

Because an ```OSData``` objects expects inline data in the data stream, ```bufferPos``` is properly incremented to skip the inline data, and then ```o``` is set to the new instance. Finally, ```next``` is also incremented, to skip the inline data.

Outside of the ```switch``` statement we have this code.

```objc
if (!(ok = (o != 0))) break;
```

If ```o``` is still ```NULL``` this means no valid object was deserialized in this loop so we exit.

```objc
if (!isRef)
{
    setAdIndex(objs, objsIdx, 0);
    if (!ok) break;
    objsIdx++;
}
```

This code is important because it is related to one of the bugs.

What is happening here is, if the deserialized object is not a reference (i.e. it is not a pointer to another object in our formatted data, you can create those via ```kOSSerializeObject```), push the object inside the ```objsArray``` array. That is an array created by ```OSUnserializedBinary``` to keep track of every deserialized object, except references.

Here is the ```setAtIndex``` macro.

```objc
#define setAtIndex(v, idx, o)                                                           
    if (idx >= v##Capacity)	                                                        
    {                                                                                   
        uint32_t ncap = v##Capacity + 64;                                               
        typeof(v##Array) nbuf = (typeof(v##Array)) kalloc_container(ncap * sizeof(o));  
        if (!nbuf) ok = false;                                                          
        if (v##Array)                                                                   
        {                                                                               
            bcopy(v##Array, nbuf, v##Capacity * sizeof(o));                             
            kfree(v##Array, v##Capacity * sizeof(o));                                   
        }                                                                               
        v##Array    = nbuf;                                                             
        v##Capacity = ncap;                                                             
    }                                                                                   
    if (ok) v##Array[idx] = o;
```

If the index we try to store is bigger than the size, the array is grown. Otherwise a dereference and set is preformed.

```objc
if (dict)
if (dict)
{
        if (sym)
        {
            if (o != dict) ok = dict->setObject(sym, o, true);
            o->release();
            sym->release();
            sym = 0;
        }
        else
        {
            sym = OSDynamicCast(OSSymbol, o);
            if (!sym && (str = OSDynamicCast(OSString, o)))
            {
                sym = (OSSymbol *) OSSymbol::withString(str);
                o->release();
                o = 0;
            }
            ok = (sym != 0);
        }
    }
    else if (array)
    {
        ok = array->setObject(o);
        o->release();
    }
    else if (set)
    {
        ok = set->setObject(o);
       o->release();
   }
    else
    {
        assert(!parent);
        result = o;
    }
```

The ```if else``` statement is responsible for storing every deseralized object into the *container* discussed earlier. Remember the three variables (```dict```, ```array``` and ```set```) will be ```NULL``` on the first iteration until a dictionary, array, or set is found in the data stream.

This means that the ```result``` pointer (the returned object) will keep shifting foward in the data until a proper *container* is found. Hence, every object on the first level (level 0) before a valid container i.e ```dict```, ```array```, or ```set``` will be ignored.

If we focus on the ```if (dict)``` branch, because it is related to the use-after-free bug. A dictionary must contain  alternating objects, one representing a key the next being a value ad infinitum. The key as the ```OSUnserializeBinary``` format specifies, must be either an ```OSString``` or an ```OSSymbol```. If it is an ```OSString```, it will be converted to an ```OSSymbol``` automatically, as seen in the snippet above.

Now, that the code is there to maintaint the alternation between keys and values. ```sym``` will start as ```NULL``` on the first iteration, so the casting to ```OSSymbol```, or ```OSString``` and then to ```OSSymbol``` will succeed. On the next iteration, we will he dealing with the value for that coresponding key. Since ```sym``` is now set, the ```if (sym)``` branch will be taken, and ```dict->setObject(sym, o, true)``` will properly set the key/value pair in the dict. ```sym``` will then be set to ```NULL``` again, since on the next iteration we are expecting a key, then a value and so on.
